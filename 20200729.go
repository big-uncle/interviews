package main

import "time"

func main() { //map为什么是无序的，那么他无序每次遍历的顺序一样吗
	m1 := make(map[string]string, 0)
	m1["1"] = "1"
	m1["2"] = "2"
	m1["3"] = "3"
	m1["4"] = "4"
	m1["5"] = "5"
	m1["6"] = "6"
	for {
		for k, _ := range m1 {
			println(k)
			time.Sleep(1 * time.Second)
		}
		println("----------------------")
		time.Sleep(2 * time.Second)
	}
} //结果每次输出顺序都不一样的，如果没有随机数，那么他顺序是固定的，但是每次遍历起始位置被赋予了随机值
// 它生成了随机数。用于决定从哪里开始循环迭代。更具体的话就是根据随机数，选择一个桶位置作为起始点进行遍历迭代
// 因此每次重新 for range map，你见到的结果都是不一样的。那是因为它的起始位置根本就不固定！

// 官方说明：
// 看起来是因为大家在使用Go的map时，可能会在业务逻辑中依赖map key的稳定遍历顺序，而Go底层实现并不保证这一点。
// 因此，Go语言索性对key次序做随机化，[以提醒大家不要依赖range遍历返回的key次序

// 读完上面的内容，我的理解就是：如果没有设置这个随机数，那么在大多数情况下，
// golang会表现出map的顺序是固定的情况。但是golang底层并没有保证这一点，
// 或许(现在/以后)会有特殊情况出现顺序不固定的情况。担心开发者们误解这一点，
// golang就特意去打乱了这个顺序，让开发者们知道golang底层不保证map每次遍历都是同一个顺序。
//输出
// 2
// 3
// 4
// 5
// 6
// 1
// ----------------------
// 3
// 4
// 5
// 6
// 1
// 2
// ----------------------
// 1
// 2
// 3
// 4
// 5
// 6
// ----------------------
// 1
// 2
// 3
// 4
// 5
// 6
// ----------------------
// 4
// 5
// 6
// 1
// 2
// 3
// ----------------------

// 数组是值类型，因此改变副本的值不会改变本身的值
// a、值类型：基本数据类型，int,float,bool,string,以及数组和struct
// 特点：变量直接存储值，内存通常在栈中分配，栈在函数调用完会被释放

// b、引用类型：指针，slice，map，chan等都是引用类型
// 特点：变量存储的是一个地址，这个地址存储最终的值。内存通常在堆上分配，通过GC回收
